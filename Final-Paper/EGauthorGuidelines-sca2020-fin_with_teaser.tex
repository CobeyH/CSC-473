% ---------------------------------------------------------------------------
% Author guideline and sample document for EG publication using LaTeX2e input
% D.Fellner, v1.15, Dec 14, 2018

\documentclass{egpubl}
\usepackage{sca2020}
 
% --- for  Annual CONFERENCE
% \ConferenceSubmission   % uncomment for Conference submission
% \ConferencePaper        % uncomment for (final) Conference Paper
% \STAR                   % uncomment for STAR contribution
% \Tutorial               % uncomment for Tutorial contribution
% \ShortPresentation      % uncomment for (final) Short Conference Presentation
% \Areas                  % uncomment for Areas contribution
% \MedicalPrize           % uncomment for Medical Prize contribution
% \Education              % uncomment for Education contribution
% \Poster                 % uncomment for Poster contribution
% \DC                     % uncomment for Doctoral Consortium
%
% --- for  CGF Journal
% \JournalSubmission    % uncomment for submission to Computer Graphics Forum
% \JournalPaper         % uncomment for final version of Journal Paper
%
% --- for  CGF Journal: special issue
% \SpecialIssueSubmission    % uncomment for submission to , special issue
\SpecialIssuePaper         % uncomment for final version of Computer Graphics Forum, special issue
%                          % EuroVis, SGP, Rendering, PG
% --- for  EG Workshop Proceedings
% \WsSubmission      % uncomment for submission to EG Workshop
% \WsPaper           % uncomment for final version of EG Workshop contribution
% \WsSubmissionJoint % for joint events, for example ICAT-EGVE
% \WsPaperJoint      % for joint events, for example ICAT-EGVE
% \Expressive        % for SBIM, CAe, NPAR
% \DigitalHeritagePaper
% \PaperL2P          % for events EG only asks for License to Publish

% --- for EuroVis 
% for full papers use \SpecialIssuePaper
% \STAREurovis   % for EuroVis additional material 
% \EuroVisPoster % for EuroVis additional material 
% \EuroVisShort  % for EuroVis additional material

% !! *please* don't change anything above
% !! unless you REALLY know what you are doing
% ------------------------------------------------------------------------
\usepackage[T1]{fontenc}
\usepackage{dfadobe}  

%\usepackage{cite}  % comment out for biblatex with backend=biber 
% ---------------------------
\biberVersion
\BibtexOrBiblatex
\usepackage[backend=biber,bibstyle=EG,citestyle=alphabetic,backref=true]{biblatex} 
\addbibresource{egbibsample.bib}
% ---------------------------  
\electronicVersion
\PrintedOrElectronic

% for including postscript figures
% mind: package option 'draft' will replace PS figure by a filename within a frame
\ifpdf \usepackage[pdftex]{graphicx} \pdfcompresslevel=9
\else \usepackage[dvips]{graphicx} \fi

\usepackage{egweblnk} 
% end of prologue

\begin{document}
\section{Abstract}
In this project, a simple simulator was created to model multi-agent evolution. Evolution is typically very slow and difficult to observe on the timescale of a human life. However, computer animation provides an excellent framework for modelling evolution with very rapid generations and a high mutation rate to observe the effects quickly. A flocking method called boids was utilized to create interesting looking flocks that could work together to overcome a predator. Boids provides a very simple set of rules that produce realistic looking behaviour with emergent behaviour.
\par
The Boids were extended by creating multiple distinct flocks which each had members created with a random value for mass, speed, cohesion, alignment and separation. Each of these attributes would influence the survival rate of the boids, the interactions with other boids in their flock and the predators. A food system was also added force the boids to eat in order to survive. Each simulation tick increases the boids hunger and their desire to find food.
\par
If a boid dies, either from starvation or from a predator boid, then a new boid is created by randomly selecting attributes from two random boids. These attributes also has a chance to increase or decrease by a small amount through a mutation mechanism.
\par
This method produced the desired results in which the average value of each attribute would increase or decrease over time until the optimal value was found for each. \textbf{FINISH RESULTS} 
\section{Introduction}
\section{Related Work}
The majority of this project was created from scratch with inspiration drawn from real life. However, several sources were used to create the initial boid behaviour and perform performance optimizations to increase the number of boids the application could support.
\par
Craig W. Reynolds' paper entitles "Flocks, Herds, and School: A Distributed Behavioral Model" provided the groundwork for how boid flocking forces work and the inspiration for the project \textbf{CITE HERE}. In addition, a spacial subdivision optimization data structure called Quadtrees were implemented in this project to improve the performance. This data structure was implemented with the help of a Wikipedia article that provided pseudocode to get started with the basic functions \textbf{CITE HERE}.
\section{Overview}
In this project, an evolution simulator was created using Boids to model flocking behaviour for the agents. The project will be described as several different subsystems that each work together in the completed product. A main goal of this project was to create an evolution simulation that didn't have a clear optimal stragety from the beginning. As such, every advantage given to the Boids has a drawback which makes it difficult to guess the outcome of a given set of parameters without running the simulation.
\subsection{Boids}
\label{forces}
The groundwork of the project uses boid simulation to create interesting flocks. The standard Boid simulation uses three forces which work together to create flocks of birds and creating an interesting emergent behaviour from simple rules. The first of these rules is separation which provides a repulsive force to boids that get too close to each other. The force is only applied when the boids are within a specified radius of each other and gets stronger as the boids crowd each other more. The second force is an attractive force that pulls all boids to the center of the flock. This force keeps the flocks in a group and will be known as the cohesion force. The final rule causes each Boid to try to align their velocity with the average velocity of boids in their flock. This causes the Boids to move together in the same direction instead of circling each other. This final force is called the alignment force.
\par
Every 0.01 seconds the three fundamental forces are recalculated for each Boid and added to the velocity of each Boid. This created two problems that had to be addressed: the velocity would increase without bound which created unnatural movement and the boids would instantly change their velocity to the new direction. The first problem was solved by implementing a maximum velocity for the boids. After the velocity change was calculated and added to the current velocity of the Boid, the totally velocity vector is normalized to create a unit vector in the direction of the Boids movement. This unit vector is then scaled by the maximum allowed velocity to create a vector in the direct direction and with a fixed maximum magnitude. 
\par
To fix the Boids turning too rapidly, a solution called "turn rate" was created that would take a portion of the desired velocity update. The system starts with the current velocity of the Boid and the velocity of the boid that was calculated after adding the three fundamental forces. The difference between these vectors is computed to get the change in velocity, which is then scaled by a fraction such as 1/10 to get a portion of the desired velocity change. This change is then added to the current velocity of the Boid to create a final result. This system is ideal because it is simple and computationally inexpensive, but it suffers from creating a variable turn rate depending on the the magnitude of the velocity change. If the Boids desired velocity is significantly different than its current velocity than it will turn faster compared to a Boid that is travelling at a velocity that is close to its desired velocity. If a constant turn rate is desired then the velocity change could be normalized and scaled by a constant using the method described for velocity limiting. For this project, the computation cost of normalizing the turn rate was deemed too expensive so a dynamic turn rate was used.
\subsubsection{Multiple Flocks}
With the basic Boid implementation complete, this system needed to be further extended with the ability to add multiple flocks of Boids. This feature is important for working towards an evolution simultor and provides several other benifits to the overall system. Creating multilpe flocks is a relatively simple procedure that involved splitting the desired number of Boids into several equal sized groups. Each flock then updates its velocity every time step based on nearby members of their own flock. This provides a huge advantage of reducing the number of nearby Boids that each individual Boid needs to consider. The nature of the Boid algorithm is $O(n^2)$ which means that if there are $n$ Boids created then each Boid needs to perform $n$ checks. This means that a system with 1000 boids would need to perform $1000 * 1000 =  1,000,000$ checks per tick. Using an example of 5 flocks we can see how having multiple independant flocks can reduce the number of checks per tick. If the 1000 boids were divided between 5 flocks then each Boid would only need to check 199 other boids. This would result in $200 * 200 * 5 = 200,000$ checks per tick. This simple division creates a 5x improvement in the number of checks that are needed per tick in this case.
\par
It is worth noting that the multiple independant flock approach loses some granular control this is available when all Boids in contained in a single flock. For example, the Boids no longer check separation force between themselves and members of other flocks which means that collisions can occur.
\subsubsection{Predators}
\label{hunting}
In order for evolution to occur, the boids needed a mechanism to determine which Boids were the weakest. This was accomplished by introducting predators into the system that actively hunt and kill Boids. The predator isn't a member of a flock and is therefore not influenced by the flocking forces described in section \ref{forces}. Instead, the predator travels in a straight line until it's hunger increases above 20\% of its maximum hunger amount. Hunger is described in a greater detail in section \ref{hunger}. Once this threshold is reached, the predator switches into a hunting state and will try to catch food. On each step, every predator calculates the closest Boid to its current location and determines the vector between itself and the prey. A portion of that vector is added to the predator's velocity similar to the "turning rate" method described previously. If a predator is within a small range of a Boid, then the boid is killed and the predators hunger bar is reset to 0. 
\subsection{Working as a Flock}
Everything described so far in this project has discussed how flocking behaviour is created, but doesn't provide a motivation for why the Boids should create flocks. This project aimed to provide motivation for the Boids to flock instead of enforcing arbitrary rules on the agents. This section discusses how the Boid behaviour was modified to provide realistic insentives for Boids to group together.
\subsubsection{Herd Safety}
In nature, the main reason for birds to flock together is to outnumber predators which increases their survival chance. This project emulated this behaviour by implementing a deterant for predators hunting habits based on the density of Boids.
\par
An extension of the predator hunter behaviour was created that prevented the predator from persuing Boids that were part of a large local group. The predator looks at Boids one at a time from each flock, starting at the closest and working outwards until a target is found. For each Boid, a radius is drawn around the potential target and a list of Boids that are also members of that flock is returned. The total mass of these boids is added up and compared to a threashold level. If the mass is below the threshold then the predator stops looking for prey and uses that target to calculate a change in velocity as described in section \ref{hunting}. If the total mass is above the threshold then it continues on to the next potential target. The target is recalculated each tick of the simulation which means the predator can search for new prey if its first target is too fast to catch or joins together with a larger group of its flock before the predator can catch it.
\subsubsection{Hunger and Food}
\label{hunger}

\subsection{Evolution}
\subsection{QuadTrees}
\section{Evaluation}
\section{Conclusion}
\printbibliography                
\end{document}
